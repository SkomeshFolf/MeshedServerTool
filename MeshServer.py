"""
    # Meshed Server Tool

    Author: Skomesh
    Version 2.0.0

    Mesh Server Tool is a Python script designed to monitor and analyze log files generated by SCP 5k game servers. 
    It keeps track of user joins and leavings and automatically restart the server.

    ## Features

    - Real-time Analysis: Continuously monitors log files for changes and provides real-time analysis.
    - Player Tracking: Tracks player joins and disconnects, by their Steam IDs.
    - Game Mode Changes: Monitors changes in the game mode and logs when transitions occur.

    ## Dependencies

    - pygtail: A Python library for tailing log files.
    - psutil: A cross-platform library for retrieving information on running processes and system utilization.
    - flask: Web framework for the local web server.
    - flask-bootstrap: Web framework for the local web server.
    - gunicorn: Web framework for the local web server.
    - requests: Used to web server monitoring.

    Use this command in command prompt or terminal to install the dependencies:
    pip install -r requirements.txt
	
	## Usage
    # On Linux
	Execute the LaunchManager.sh script from inside the LaunchScripts directory.
	./LaunchManager.sh
	To start the web server, execute the LaunchWebServer.sh script.
	
	# On Windows
	Run the LaunchManager.bat file.
	To run the web server, run the LaunchWebServer.bat file.	

    ## Configuration

    # General configuration:
	Launching the server management tool will create a config.ini file. 
	
    The following are the parameters in the newly created config.ini file:
        [General]
            - log_checking_interval:    How often should the log file have new lines be evaluated?
                                        Lower means higher frequency, but higher system usage.
        [WebServer]
            - web_server_enabled:       true or false. If true, the tool assumes that the monitoring web server is active and will use it.
            - web_server_address:       Custom address of the web server. If hosted on same machine, this is usually '127.0.0.1'.
            - web_server_port:          Port of the web server. By default is 5000.
        [MOTD]
            - global_server_motd:       An MOTD message that will be used in every server instance if there is no server specific MOTD.

    # Server configuration:
	Create a directory with name: Server_[server name].
	
    Launching the server manager will create a new config file for the server.
	
    The following are the parameters in the newly created config.ini file
        - log_file_path:        The directory of the server's log file. The log file should be Pandemic.log.
        - saved_directory_path: The directory to the "Saved" folder. From the root folder, should be in Pandemic/Saved
        - max_reloads:          How many map changes should lead to a full server restart.
        - restricted_gamemode:  Should the server be restricted to only a single gamemode? Leave blank to allow map switching.
        - server_executable:    The directory to the actual server executable. Should be PandemicServer.exe on windows, or PandemicServer on linux.
                                    The executable should be in /Pandemic/Binaries/Linux OR WindowsServer/PandemicServer.exe
        - server_args:          Any arguments to be passed to the server, such as -port and -queryport. Each argument separated by commas
                                    ex. M_WaveSurvival,-port=7777,-queryport=27015
        - active_hours:         What time should the server be active for? In format HH:MM-HH:MM (ex 08:00-18:00)
        [MOTD]
            - motd:          What should be the server's MOTD be. Each message should separated by a /
            - join_motd:     What should the server post when players join. Each message should be separated by a /
            - crash_motd:    Should the server put the last crash in the MOTD?

    ## TODO 
    
    - Server Management:
        - Make better checks to find current gamemodes
    - Webpage:
        - Add logic to make streams more efficient
        - Add logs per server
        - Add log page where you can search, sort and scroll pages
        - Add a server creation page
        - Add global ban list
        - Add edit server settings
            - Edit server management config
                - Server name
                - Server installation directory
                - Max server reloads
                - Restricted Gamemode
                - Arguments
                    - Dropdown field for map
                    - Field for port
                    - Field for steam query port
                    - Autoset SteamServerName to server name
                    - Other args
                - Active hours
                - MOTD
                - Join MOTD
                - Crash MOTD
            - Edit game server config
        - Add webpage settings
            - Dark theme
        - Add global settings
            - Global MOTD
            - Global Admins
            - Global Owners
            - Global Whitelist
"""

import re
import subprocess
import time
import pygtail
import threading
import requests
import json
import os
import platform
import configparser
import psutil
import ast
from datetime import datetime, time, timedelta
import time
import shutil
import socket
import traceback
import hashlib
from platformdirs import user_data_dir, user_config_dir, user_cache_dir

class OSErrorDetectionError (Exception):
    def __init__ (self, message="Either unable to detect the current OS or current OS is not supported."):
        self.message = message
        super().__init__(self.message)

class Server:
    def __init__(self, name, config, server_info):
        self.name = name
        self.server_info = server_info
        self.config_path = config

        self.server_process = None
        self.log = None
        self.analysis_thread = None
        self.server_started = False

        self.current_line = 0
        self.idle_time = -1
        self.log_check_interval = int (read_global_config()['General']['log_checking_interval'])
        self.last_crash = None
        self.manual_kill_flag = False
        self.manual_shutdown_flag = False

        self.lock = threading.Lock()

    def create_server (self, shared_dir=False):
        self.server_info.server_status_change (-5)
        register_server_creating (self.name)
        self.read_server_config ()
        self.launch_server_dry (shared_dir)
        time.sleep (3)
        self.kill_server ()

    def init_server (self):
        self.read_server_config ()

        if not self.check_if_valid_install_dir():
            self.wait_for_valid_install_dir()

        UserReport.register_reports_directory (self.saved_file_path + '/Reports')

        self.start_server()
        self.start_log_analysis()
    
    def read_server_config (self):
        self.config = read_config (self.config_path)
        self.update_config_settings()
    
    def update_config_settings (self):
        self.server_name = self.config['General']['server_name']
        self.install_dir = self.config['General']['install_dir']
        self.shared_dir = ast.literal_eval (self.config['General']['shared_install_dir'])
        self.max_reloads = int(self.config['General']['max_reloads'])
        self.starting_gamemode = self.config['General']['starting_gamemode']
        self.restricted_gamemode = self.config['General']['restricted_gamemode']
        self.port = int(self.config['General']['port'])
        self.query_port = int(self.config['General']['queryport'])
        self.server_args = self.config['General']['server_args']

        self.update_file_paths()

        self.update_config_saved_path ()

        if (self.config['General']['active_hours'] == ''):
            self.active_hours = False
        else:
            timeSplit = self.config['General']['active_hours'].split("-")
            self.active_hours = True
            self.start_time = datetime.strptime (timeSplit[0], '%H:%M').time()
            self.end_time = datetime.strptime (timeSplit[1], '%H:%M').time()

    def update_server_path_name (self, new_name):
        self.name = new_name
        self.server_info.server_name = new_name
        self.config_path = os.path.join (f"Server_{new_name}", "config.ini")
        self.read_server_config ()
        
    def update_file_paths (self):
        os_name = platform.system ()
        if os_name == "Windows":
            if self.shared_dir:
                self.log_file_path = os.path.join(self.install_dir, 'WindowsServer', 'Pandemic', 'Saved', 'Logs', self.server_name, f'{self.server_name}.log')
            else:
                self.log_file_path = os.path.join(self.install_dir, 'WindowsServer', 'Pandemic', 'Saved', 'Logs', 'Pandemic.log')
            self.saved_file_path = os.path.join(self.install_dir, 'WindowsServer', 'Pandemic', 'Saved')
            self.server_executable = os.path.join(self.install_dir, 'WindowsServer', 'PandemicServer.exe')
        elif os_name == "Linux":
            if self.shared_dir:
                self.log_file_path = os.path.join(self.install_dir, 'LinuxServer', 'Pandemic', 'Saved', 'Logs', self.server_name, f'{self.server_name}.log')
            else:
                self.log_file_path = os.path.join(self.install_dir, 'LinuxServer', 'Pandemic', 'Saved', 'Logs', 'Pandemic.log')
            self.saved_file_path = os.path.join(self.install_dir, 'LinuxServer', 'Pandemic', 'Saved')
            self.server_executable = os.path.join(self.install_dir, 'LinuxServer', 'Pandemic', 'Binaries', 'Linux', 'PandemicServer')
        else:
            raise OSErrorDetectionError
    
    def update_config_saved_path (self):
        config = configparser.ConfigParser()
        config.read (self.config_path)
        config.set ('General', 'saved_path_dont_touch', self.saved_file_path)
        with open (self.config_path, 'w') as configfile:
            config.write (configfile)

    def check_if_valid_install_dir (self):
        if os.path.exists (self.install_dir):
            if os.path.exists (self.install_dir + "/WindowsServer") or os.path.exists (self.install_dir + "/LinuxServer"):
                return True
            else:
                return False
        else:
            return False
    
    def wait_for_valid_install_dir (self):
        path_valid = False

        while not path_valid:
            print (f"{self.server_name} could not find server at {self.install_dir}. Please update config with the server\'s root. Will retry in 10 seconds.")
            
            self.read_server_config()
            path_valid = self.check_if_valid_install_dir()

            time.sleep (10)

    def start_log_analysis (self):
        thread = threading.Thread (target=self.analyze_log, daemon=True)
        thread.start()

    def start_server (self):
        self.server_info.server_status_change (2)
        register_server_start (self.name)
        self.read_server_config()
        update_server_path_name (self.name) 
        self.init_motd ()
        self.reset_vars()
        self.launch_server()
        
    def launch_server (self):
        if not self.server_process:
            essential_server_args = [
                self.starting_gamemode,
                '-log',
                f"-port={self.port}",
                f"-queryport={self.query_port}",
                f"-SteamServerName={self.server_name}"
            ]

            if self.shared_dir:
                essential_server_args.append (f"-Log={self.server_name}/{self.server_name}.log")
                essential_server_args.append (f"-ConfigFileName={self.server_name}.ini")

            server_args_raw = self.server_args
            server_args = essential_server_args + server_args_raw.split(',')
            command = [self.server_executable] + server_args
            self.server_process = subprocess.Popen(command)
            self.server_info.server_restarts = self.server_info.server_restarts + 1

    def launch_server_dry (self, shared_dir):
        server_args_raw = []
        if shared_dir:
            server_args_raw = [
                "-log",
                f"-Log={self.server_name}/{self.server_name}.log",
                f"-ConfigFileName={self.server_name}.ini"
            ]
        else:
            server_args_raw = [
                "-log"
            ]
        server_args = server_args_raw
        command = [self.server_executable] + server_args
        self.server_process = subprocess.Popen(command)

    def execute_server_start (self):
        self.manual_kill_flag = False
        self.manual_shutdown_flag = False
        self.start_server()

    def execute_server_restart (self):
        self.restart_server ("Manual Restart")

    def execute_server_stop (self):
        self.manual_shutdown_flag = True

    def execute_server_kill (self):
        self.manual_kill_flag = True
        self.shutdown_server ()

    def wake_server (self):
        self.server_info.server_status_change (1)
        register_server_wake (self.name)
        time.sleep (3)
        self.init_server()

    def active_server (self):
        self.idle_time = -1
        if self.server_info.server_status != 5:
            self.idle_time = -1
            self.server_info.server_status_change (5)
            register_server_active (self.name)

    def stop_server(self):
        self.server_info.server_status_change (0)
        register_server_stop (self.name)
        time.sleep (2)
        if self.server_process:
            self.kill_server()
    
    def shutdown_server(self):
        self.stop_server()
        self.reset_vars()
        self.server_info.server_status_change (-3)
      
    def kill_server (self):
        if self.server_process:
            try:
                parent_pid = self.server_process.pid
                parent = psutil.Process(parent_pid)
                children = parent.children(recursive=True)
                for child in children:
                    child.terminate()
                psutil.wait_procs(children, timeout=10)
                parent.terminate()
                parent.wait(timeout=10)
                self.server_info.server_status_change (-3)
                register_server_offline (self.name)
            except psutil.NoSuchProcess:
                pass
            finally:
                self.server_process = None

    def suspend_server(self):
        self.shutdown_server()
        self.server_info.server_status_change (-1)
        register_server_suspend (self.name)

        while True:
            if self.is_active_hours (self.start_time, self.end_time):
                break

            time.sleep (60)
        
        self.wake_server()

    def restart_server(self, reason):
        self.server_info.server_status_change (3)
        register_server_restart (self.name, reason)
        if not reason:
            self.init_motd()

        time.sleep (0.5)
        self.stop_server()
        time.sleep (1)
        self.start_server()
        
    def idle_server (self):
        self.idle_time = time.time()
        self.server_info.server_status_change (4)
        register_server_idle (self.name)

    def server_crashed (self):
        print ("Server crashed")
        self.last_crash = datetime.now().time()
        self.server_info.server_status_change (-2)
        time.sleep (3)
        self.restart_server ("Server crash")

    def reset_vars(self):
        self.log = None
        self.server_info.previous_gamemode = None
        self.server_info.joined_users = set()
        self.server_info.disconnected_users = set()
        self.server_info.current_users = set()
        self.server_info.total_user_joins = 0
        self.server_info.total_user_disconnects = 0
        self.server_info.gamemode_changes = 0
        self.current_line = 0
        self.server_started = False
        self.last_crash = None

    def init_motd (self):
        path = self.saved_file_path
        config = self.config
        global_motd = read_global_config()['MOTD']['global_server_motd']
        motd = self.config['MOTD']['motd']
        join_motd = self.config ['MOTD']['join_motd']
        crash_motd = ast.literal_eval (config ['MOTD']['crash_motd'])
        
        with open(f"{path}/Messages.ini", 'w') as message_file:
            if (motd and motd != ''):
                if crash_motd != None and self.last_crash != None:
                    message_file.write(f"{global_motd}/{motd.strip()}/The last server crashed was at: {self.last_crash.strftime('%H:%M')} PST. Lets hope it doesn't crash again!,0,00:05:00\n")
                else:
                    message_file.write(f"{global_motd}/{motd.strip()},0,00:07:30\n")
            if join_motd and join_motd != '':
                message_file.write (f"{join_motd},2,00:00:07\n")
            if self.active_hours:
                end_time = datetime.combine (datetime.today(), self.end_time)

                message_file.write (f"The server will be shutdown in one hour., 1, {(end_time - timedelta(hours=1)).time().strftime('%H:%M')}:00\n")
                message_file.write (f"The server will be shutdown in 30 minutes., 1, {(end_time - timedelta(minutes=30)).time().strftime('%H:%M')}:00\n")
                message_file.write (f"The server will shutdown after this game ends., 1, {end_time.time().strftime('%H:%M')}:00\n")
   
    def is_active_hours (self):
        current_time = datetime.now().time()
        if self.start_time <= current_time <= self.end_time:
            return True
        else:
            return False

    def analyze_log(self):
        # If this starts when we are beyond the active hours, if it is, suspend.
        if self.active_hours:
            if not self.is_active_hours ():
                self.suspend_server()
                return
        
        with self.lock:
            # Keep analyzing the log until it should stop.
            # This will continue until the server suspends.
            server_logging = True
            while server_logging and not self.manual_kill_flag:
                time.sleep(3)

                # Setup the log file for reading
                try:
                    self.log = pygtail.Pygtail(self.log_file_path)
                except FileNotFoundError:
                    print(f"Error: Log file {self.log_file_path} not found.")
                    return
                
                # Keep executing while the server is active.
                # Server will be labeled inactive if the server restarts, suspends or crashes.
                server_active = True
                while server_active and not self.manual_kill_flag:

                    # Check if the server has crashed
                    if self.server_process != None:
                        if self.server_process.poll() != None:
                            self.server_crashed()
                            server_active = False
                            break
                    else:
                        self.server_crashed()

                    # Has the server been idle for 30 minutes? Should the server restart anyways?
                    '''
                    if self.idle_time > 0:
                        if self.server_info.gamemode_changes > 1:
                            if time.time() > self.idle_time + 30:
                                self.restart_server("Server idle")
                    '''

                    # Go through each new line 
                    with open(self.log_file_path, 'r') as log_file:
                        for _ in range(self.current_line):
                            log_file.readline()

                        for line in log_file:
                            self.current_line += 1

                            # Is the latest log a gamemode change?
                            game_class = log_is_new_gamemode(line)
                            if game_class:
                                if self.manual_shutdown_flag:
                                    self.shutdown_server()
                                    server_active = False
                                    server_logging = False
                                    break

                                # Suspend the server if beyond active hours
                                if self.active_hours:
                                    if not self.is_active_hours ():
                                        self.suspend_server()
                                        server_active = False
                                        server_logging = False
                                        break
                                
                                # Check if new gamemode is an idle state
                                if game_class == "Entry":
                                    self.idle_server()
                                else:
                                    self.server_info.gamemode_change (game_class)
                                    # Declare the server is active
                                    self.active_server ()

                                # Check if server should restart for either max gamemode changes or loading the wrong gamemode.
                                if self.server_info.gamemode_changes > self.max_reloads:
                                    self.restart_server(f"Server reloaded {self.server_info.gamemode_changes} times")
                                    server_active = False
                                    break
                                elif self.restricted_gamemode != '' and self.server_info.previous_gamemode != self.restricted_gamemode:
                                    self.restart_server(f"Server loaded a gamemode that is not {self.restricted_gamemode}")
                                    server_active = False
                                    break

                            # Is the latest log a player joining? Log it in the server info.
                            player_id = log_is_player_joined(line)
                            if player_id:
                                self.server_info.player_join(player_id)

                            # Is the latest log a player leaving? Log it in the server info.
                            player_id = log_is_player_leave(line)
                            if player_id:
                                self.server_info.player_leave(player_id)

                            # Is the latest log the server entering an idle state? Enter idle state.
                            server_idle = log_is_entering_idle (line)
                            if server_idle:
                                self.idle_server()

                            server_activating = log_is_game_starting (line)
                            if server_activating:
                                self.active_server()
                            
                            # Is this the first time the server has started? Init the server.
                            if not self.server_started:
                                start_mode = log_is_starting_gamemode (line)
                                session_create = log_is_session_creation (line)

                                if start_mode:
                                    self.server_info.gamemode_change (start_mode)

                                if session_create:
                                    self.server_info.server_status_change (4)
                                    self.idle_server()
                                    self.server_started = True
                                
                    send_server_info ()
                    time.sleep(self.log_check_interval)

class ServerInfo:
    def __init__ (self, name):
        self.server_name = name
        self.previous_gamemode = None
        self.joined_users = set()
        self.disconnected_users = set()
        self.current_users = set()
        self.gamemode_changes = 0
        self.total_user_joins = 0
        self.total_user_disconnects = 0
        self.server_restarts = 0
        self.server_status = 'Offline'
    
    def player_join (self, player):
        self.total_user_joins += 1
        self.joined_users.add(player)
        self.current_users.add(player)
        register_player_join (self.server_name, player)
    
    def player_leave (self, player):
        self.total_user_disconnects += 1
        self.disconnected_users.add(player)
        self.current_users.discard(player)
        register_player_leave (self.server_name, player)

    def gamemode_change (self, gamemode):
        if gamemode != self.previous_gamemode:
            self.gamemode_changes += 1
            self.previous_gamemode = gamemode
        register_server_gamemode (self.server_name, gamemode)
    
    def reset_variables (self):
        self.previous_gamemode = None
        self.joined_users = set()
        self.disconnected_users = set()
        self.current_users = set()
        self.gamemode_changes = 0
        self.total_user_joins = 0
        self.total_user_disconnects = 0

    def server_status_change (self, new_status):
        status_dict = {
            -5: 'Creating',
            -3: 'Offline',
            -2: 'Crashed',
            -1: 'Suspended',
            0: 'Stopping',
            1: 'Waking',
            2: 'Starting',
            3: 'Restarting',
            4: 'Idle',
            5: 'Active'
        }
        self.server_status = status_dict.get (new_status, 'Offline')
        send_server_info()
    
    def __repr__(self):
        return f"ServerInfo(server_name={self.server_name}, " \
               f"previous_gamemode={self.previous_gamemode}, " \
               f"joined_users={self.joined_users}, " \
               f"disconnected_users={self.disconnected_users}, " \
               f"current_users={self.current_users}, " \
               f"gamemode_changes={self.gamemode_changes}, " \
               f"total_user_joins={self.total_user_joins}, " \
               f"total_user_disconnects={self.total_user_disconnects}, " \
               f"server_restarts={self.server_restarts}, " \
               f"server_status={self.server_status})"
    
class UserReport:
    report_directories = []
    checking_thread = None

    def __init__ (self, target, target_id, source, source_id, date, reason, text):
        self.target = target
        self.target_id = target_id
        self.source = source
        self.source_id = source_id
        self.date = date
        self.reason = reason
        self.text = text
        self.hash = self.generate_hash()

    def generate_hash (self):
        hasher = hashlib.md5()
        hasher.update(f"{self.target}{self.target_id}{self.source}{self.source_id}{self.date}{self.reason}{self.text}".encode('utf-8'))
        return hasher.hexdigest()
    
    @staticmethod
    def register_reports_directory (dir):
        if dir not in UserReport.report_directories:
            UserReport.report_directories.append(dir)

    @staticmethod
    def remove_reports_directory (dir):
        UserReport.report_directories.remove (dir)

    @staticmethod
    def start_report_checking_thread ():
        if UserReport.checking_thread is None:
            UserReport.checking_thread = threading.Thread(target=UserReport.report_checking_thread, daemon=True).start()
    
    @staticmethod
    def report_checking_thread ():
        time.sleep (5)
        while True:
            UserReport.search_directories ()
            time.sleep (60)

    @staticmethod
    def search_directories ():
        new_reports = []
        for directory in UserReport.report_directories:
            if not os.path.isdir(directory):
                print(f"[UserReport.search_directories] Warning: Directory '{directory}' does not exist.")
                UserReport.remove_reports_directory (directory)
                continue
            
            for filename in os.listdir(directory):
                file_path = os.path.join(directory, filename)
                if os.path.isfile(file_path):
                    with open(file_path, 'r') as file:
                        file_contents = file.read()
                        report = UserReport.parse_report(file_contents)
                        
                        if not UserReport.has_report_been_handled (report.hash):
                            new_reports.append (report)

        send_new_reports (new_reports)
                
    @staticmethod
    def has_report_been_handled (hash):
        handled_path = os.path.join (data_dir, "handled_reports.txt")

        if not os.path.isfile(handled_path):
            with open (handled_path, 'w') as file:
                pass
    
        with open(handled_path, 'r') as file:
            for line in file:
                if line.strip() == hash:
                    return True
        
        return False

    @staticmethod
    def parse_report(file_contents):
        # Split the lines of the file
        lines = file_contents.split('\n')

        # Parse individual fields based on line number
        target_id, target = lines[0].split(',')
        source_id, source = lines[1].split(',')
        date_str = lines[2].strip()
        date = date_str
        reason = lines[4].strip()
        text = lines[5].strip()

        return UserReport(target, target_id, source, source_id, date, reason, text)

    @staticmethod
    def handle_report (hash):
        handled_path = os.path.join (data_dir, "handled_reports.txt")

        with open (handled_path, 'a') as file:
            file.write (hash + '\n')

    @staticmethod 
    def delete_report (hash):
        raise NotImplementedError
    
    def __str__ (self):
        return f"Report(server={self.server}, target={self.target}, target_id={self.target_id}, source={self.source}, source_id={self.source_id}, date={self.date}, reason={self.reason}, text={self.text}, hash={self.hash})"
    
    def __eq__ (self, other):
        if isinstance(other, UserReport):
            return self.hash == other.hash
        return False

servers = []
server_info = []
main_log_file = None
is_using_web_server = False
web_server_online = False
wait_for_web_server_thread = None

def register_player_join (server, player):
    print (f"Player {player} has joined {server}")
    write_to_log (server, f"Player {player} connected.")
    send_server_info ()

def register_player_leave (server, player):
    print (f"Player {player} has left {server}")
    write_to_log (server, f"Player {player} has disconnected.")
    send_server_info ()

def register_server_restart (server, reason):
    print (f"Server {server} has restarted for: {reason}.")
    write_to_log (server, f"Server restarted for: {reason}.")
    send_server_info ()

def register_server_gamemode (server, gamemode):
    print (f"Server {server} has changed gamemode to {gamemode}")
    write_to_log (server, f"Gamemode changed to {gamemode}.")
    send_server_info ()
    
def register_server_start (server):
    print (f"Server {server} has started")
    write_to_log (server, f"Server started.")
    send_server_info ()

def register_server_active (server):
    print (f"Server {server} is now active")
    write_to_log (server, f"Server active.")
    send_server_info ()

def register_server_stop (server):
    print (f"Server {server} has stopped")
    write_to_log (server, f"Server stopped.")
    send_server_info ()

def register_server_offline (server):
    print (f"Server {server} is now offline")
    write_to_log (server, f"Server offline.")
    send_server_info ()

def register_server_suspend (server):
    print (f"Server {server} has suspended")
    write_to_log (server, "Server suspended.")
    send_server_info ()

def register_server_wake (server):
    print (f"Server {server} woke from suspending")
    write_to_log (server, "Server waking from suspension.")
    send_server_info ()

def register_server_idle (server):
    print (f"Server {server} is now idle.")
    write_to_log (server, "Server is now idle.")
    send_server_info ()

def register_server_creating (server):
    print (f"Server {server} is being created for the first time.")
    write_to_log (server, "Server is being created for the first time.")
    send_server_info()

def register_server_created (server):
    print (f"Server {server} has successfully been created.")
    write_to_log (server, "Server has been successfully created.")
    send_server_info()

def register_web_server_error (e):
    print (f"Web Server Error: {e}")
    write_to_log ("Web Server", f"Web Server Error: {e}")

def log_is_new_gamemode(line):
    match = re.search(r'Map vote has concluded, travelling to (.+)', line)
    if match: 
        return match.group(1) if match else None

def log_is_starting_gamemode (line):
    match = re.search (r'LogLoad: LoadMap: /Game/SCPPandemic/Maps/([^/]+)/', line)
    if match:
        return match.group(1) if match else None
    
def log_is_session_creation (line):
    match = re.search (r'Create session complete', line)
    return bool (match)

def log_is_entering_idle (line):
    match = re.search (r'Entering Standby, going to standby map M_ServerDefault.', line)
    return bool (match)

def log_is_game_starting (line):
    match = re.search (r'(Game|Gamemode) has started', line)
    return match

def log_is_player_joined (line):
    match = re.search(r'Sending auth result to user (\d+)', line)
    if match:
        return match.group(1)
    
    return None

def log_is_player_leave (line):
    close_match = re.search(r'UNetConnection::Close: \[UNetConnection\] RemoteAddr: (\d+):', line)

    if close_match:
        return close_match.group(1)
    
    kick_match = re.search(r'Successfully kicked player (\d+)', line)

    if (kick_match):
        return kick_match.group(1)
    
    cleanup = re.search(r'LogNet: UChannel::CleanUp: ChIndex == \d+. Closing connection. \[UChannel\] ChIndex: \d+, Closing: \d+ \[UNetConnection\] RemoteAddr: (\d+):', line)

    if cleanup:
        return cleanup.group(1)
    
    return None

def log_is_player_id(log_file_path):
    steam_ids = set()

    with open(log_file_path, 'r') as log_file:
        for line in log_file:
            matches = re.findall(r'\b\d{17}\b', line)
            steam_ids.update(matches)

    # Log the collected Steam IDs
    print("All Steam IDs in the log file:")
    for steam_id in steam_ids:
        print(steam_id)


def execute_server_start (server):
    get_server_from_name (server).execute_server_start()

def execute_server_restart (server):
    get_server_from_name (server).execute_server_restart ()
    
def execute_server_stop (server):
    get_server_from_name (server).execute_server_stop ()

def execute_server_kill (server):
    get_server_from_name (server).execute_server_kill ()


def send_server_info ():
    global server_info
    global web_server_address
    
    # Check web server status, return if offline, not found or not used.
    if not check_web_server():
        print ("Failed to ping web server")
        return
    
    server_info_dicts = [
        {
            "server_name": info.server_name,
            "previous_gamemode": info.previous_gamemode,
            "joined_users": list(info.joined_users),
            "disconnected_users": list(info.disconnected_users),
            "current_users": list(info.current_users),
            "gamemode_changes": info.gamemode_changes,
            "total_user_joins": info.total_user_joins,
            "total_user_disconnects": info.total_user_disconnects,
            "server_restarts": info.server_restarts,
            "server_status": info.server_status
        }
        for info in server_info
    ]
    config = read_global_config()
    json_data = json.dumps (server_info_dicts)
    url = (f"http://{config['WebServer']['web_server_address']}:{config['WebServer']['web_server_port']}/update_server_info")
    try:
        json_string = {"server_info": json_data}
        response = requests.post(url, json=json_string)
    except requests.exceptions.ConnectionError as e:
        if check_web_server():
            register_web_server_error (f"Unknown Web Server Error. {e}")
            return
        else:
            register_web_server_error (f"Web server either crashed or lost connection. Attempting to reconnect.")
            return
    except requests.exceptions.Timeout as e:
        if check_web_server():
            register_web_server_error (f"Unknown Web Server Error. {e}")
            return
        else:
            register_web_server_error (f"Web server either crashed or lost connection. Attempting to reconnect.")
            return

def send_new_reports (reports):
    global server_info
    global web_server_address
    
    # Check web server status, return if offline, not found or not used.
    if not check_web_server():
        print ("Failed to ping web server")
        return
    
    report_dict = [
        {
            'target': report.target,
            'target_id': report.target_id,
            'source': report.source,
            'source_id': report.source_id,
            'date': report.date,
            'reason': report.reason,
            'text': report.text,
            'hash': report.hash
        }
        for report in reports
    ]
   
    config = read_global_config()
    json_data = json.dumps (report_dict)
    url = (f"http://{config['WebServer']['web_server_address']}:{config['WebServer']['web_server_port']}/receive_new_reports")
    try:
        response = requests.post(url, json=json_data)
    except requests.exceptions.ConnectionError as e:
        if check_web_server():
            register_web_server_error (f"Unknown Web Server Error. {e}")
            return
        else:
            register_web_server_error (f"Web server either crashed or lost connection. Attempting to reconnect.")
            return
    except requests.exceptions.Timeout as e:
        if check_web_server():
            register_web_server_error (f"Unknown Web Server Error. {e}")
            return
        else:
            register_web_server_error (f"Web server either crashed or lost connection. Attempting to reconnect.")
            return

def begin_server (name):
    global server_info, servers
    server_info_instance = ServerInfo (name)
    server_instance = Server(name, "Server_" + name + "/config.ini", server_info_instance)
    servers.append (server_instance)
    server_info.append (server_info_instance)
    server_instance.init_server()

def create_server (formdata):
    global server_info, servers

    server_name = formdata.get ('server_name')
    server_name_dir = "Server_" + server_name

    try:
        os.makedirs (f"Server_{server_name}")
    except Exception as e:
        return e

    generate_config (f"Server_{server_name}/config.ini")

    try:
        config = configparser.ConfigParser()
        config.read (f"Server_{server_name}/config.ini")

        for key, value in formdata.items():
            if config.has_option ('General', key):
                config.set ('General', key, str(value))

        with open(f"Server_{server_name}/config.ini", 'w') as configfile:
            config.write(configfile)
    except Exception as e:
        return e

    server_info_instance = ServerInfo (server_name)
    server_instance = Server(server_name, server_name_dir + "/config.ini", server_info_instance)
    servers.append (server_instance)
    server_info.append (server_info_instance)
    server_instance.create_server(formdata.get('shared_install_dir'))

    config = read_config (server_name_dir + "/config.ini")
    saved_path = config['General']['saved_path_dont_touch']

    if formdata.get ('shared_install_dir'):
        server_config = saved_path + f"/Config/{server_name}.ini"
    else:
        server_config = saved_path + f"/Config/ServerConfig.ini"

    try:
        config = configparser.ConfigParser()
        config.read (server_config)

        for key, value in formdata.items():
            if config.has_option ('/Game/SCPPandemic/Blueprints/GI_PandemicGameInstance.GI_PandemicGameInstance_C', key):
                config.set ('/Game/SCPPandemic/Blueprints/GI_PandemicGameInstance.GI_PandemicGameInstance_C', key, str(value))

        gameplay_config_str = config.get ('/Game/SCPPandemic/Blueprints/GI_PandemicGameInstance.GI_PandemicGameInstance_C', 'GameplayConfig')

        gameplay_config = parse_gameplay_config (gameplay_config_str)

        for key, value in formdata.items():
            if gameplay_config.get (key, None) is not None:
                gameplay_config[key] = value

        new_gameplay_config = format_gameplay_config (gameplay_config)

        config.set ('/Game/SCPPandemic/Blueprints/GI_PandemicGameInstance.GI_PandemicGameInstance_C', 'GameplayConfig', new_gameplay_config)
        
        with open(server_config, 'w') as configfile:
            config.write(configfile)
        
    except Exception as e:
        return e
    
    register_server_created (server_name)
    time.sleep (1)
    server_instance.init_server()

    return True

def parse_gameplay_config(config_str):
    config_str = config_str.strip('()')
    config_dict = {}
    for item in config_str.split(','):
        key, value = item.split('=')
        if value.lower() == 'true':
            value = True
        elif value.lower() == 'false':
            value = False
        elif '.' in value:
            value = float(value)
        else:
            value = int(value)
        config_dict[key] = value
    return config_dict

def format_gameplay_config (config_dict):
    config_str = ','.join([f'{key}={str(value) if isinstance(value, bool) else value}' for key, value in config_dict.items()])
    return f'({config_str})'

def update_server_path_name (server):
    global server_info, servers

    server_instance = get_server_from_name (server)
    server_instance.read_server_config()
    
    server_new_name = server_instance.server_name
    
    if server is not server_new_name:
        server_instance.server_info.server_name = server_new_name

        old_path = f"{server}"
        new_path = f"Server_{server_new_name}"

        try:
            os.rename (old_path, new_path)
        except Exception as e:
            print ("")

        try:
            os.rename ("Server_" + old_path, new_path)
        except Exception as e:
            print ("")

        server_instance.update_server_path_name (server_new_name)


def add_to_global_ban_list (user_id):
    banlist_dir = os.path.join (data_dir, "banlist.txt")

    with open (banlist_dir, 'a') as file:
        file.write (user_id + '\n')

    update_server_banlists ()

def update_server_banlists ():
    banlist = os.path.join (data_dir, "banlist.txt")
    for server in servers:
        server_banlist = os.path.join (server.saved_file_path, "BannedIDs.ini")
        shutil.copyfile (banlist, server_banlist)

def get_server_from_name (name):
    global servers

    for server in servers:
        if (server.name == name):
            return server
    
    return None


def check_web_server ():
    global is_using_web_server
    global web_server_online
    global wait_for_web_server_thread

    # Is web server used
    if is_using_web_server:    
        # Check if web server is online, and re-ping it
        if web_server_online:
            if ping_web_server():
                return True
            else:
                start_wait_for_web_server_thread()
                return False
        # If web server is not currently online, double check if we need to restart a waiting thread
        else:
            start_wait_for_web_server_thread()
            return False
    else:
        return False
    
def ping_web_server ():
    config = read_global_config()

    if not config['WebServer']['web_server_enabled']:
        return False

    try:
        response = requests.get(f"http://{config['WebServer']['web_server_address']}:{config['WebServer']['web_server_port']}")
        if response.status_code // 100 == 2:
            return True
        else:
            print(f"Server returned an error: {response.status_code}")
            return False
    except requests.ConnectionError:
        return False
    except requests.RequestException:
        return False

def wait_for_web_server ():
    global web_server_online
    global wait_for_web_server_thread
    
    while not web_server_online:
        if ping_web_server():
            web_server_online = True
            wait_for_web_server_thread = None
        time.sleep (20)

def start_wait_for_web_server_thread():
    global wait_for_web_server_thread
    if wait_for_web_server_thread == None:
        wait_for_web_server_thread = threading.Thread(target=wait_for_web_server, daemon=True).start()


def write_to_log (server, content):
    current_datetime = datetime.now()
    formatted_datetime = current_datetime.strftime("%d-%m-%Y %H.%M.%S")
    with open("log.txt", 'a') as log_file:
        log_file.write(f"\n[{formatted_datetime}] {server} - {content}")

def create_log_file():
    current_datetime = datetime.now()
    formatted_datetime = current_datetime.strftime("%d-%m-%Y %H_%M_%S")
    if not os.path.exists("log.txt"):
        with open("log.txt", 'w') as log_file:
            log_file.write(f"[Start of log file: {formatted_datetime}]\n")
    else:
        save_log_file()
        with open("log.txt", 'w') as log_file:
            log_file.write(f"[Start of log file: {formatted_datetime}]\n")

def save_log_file():
    if not os.path.exists("Logs"):
        os.makedirs("Logs")

    current_datetime = datetime.now()
    formatted_datetime = current_datetime.strftime("%d_%m_%Y-%H.%M.%S")

    shutil.move("log.txt", f"Logs/log_{formatted_datetime}.txt")

    with open("log.txt", 'w') as log_file:
        log_file.write("")    

def read_config(config_file_path):
    if not os.path.isfile (config_file_path):
        generate_config (config_file_path)

    config = configparser.ConfigParser()
    config.read(config_file_path)    
    return config

def get_all_server_paths():
    configs = []
    # Find all server folders
    server_folders = [folder for folder in os.listdir() if os.path.isdir(folder) and folder.startswith("Server_")]

    for folder in server_folders:
        config_file_path = os.path.join(folder, 'config.ini')
        configs.append({'folder': folder, 'config': config_file_path})

    return configs
    
def generate_config(config_file_path):
    newConfig = configparser.ConfigParser()
    server_dir_name = config_file_path.replace ("Server_", "").replace ("/config.ini", "")
    newConfig['General'] = {
        'server_name': server_dir_name,
        'install_dir': 'SCP Pandemic Dedicated Server',
        'shared_install_dir': 'False',
        'saved_path_dont_touch': '',
        'max_reloads': '7',
        'starting_gamemode': '',
        'restricted_gamemode': '',
        'port': '7777',
        'queryport': '27015',
        'server_args': '',
        'active_hours': ''
    }
    newConfig['MOTD'] = {
        'motd': '',
        'join_motd': '',
        'crash_motd': 'False'
    }

    with open(config_file_path, 'w') as config_file:
        newConfig.write(config_file)

    print ("Creating config at " + config_file_path)
        
def read_global_config ():
    if not os.path.exists ("config.ini"):
        generate_global_config ()
    
    config = configparser.ConfigParser()
    config.read ("config.ini")
    return config
    
def generate_global_config ():
    new_config = configparser.ConfigParser()
    new_config['WebServer'] = {
        'web_server_enabled': True,
        'web_server_address': '127.0.0.1',
        'web_server_port': 5000
    }
    new_config['General'] = {
        'log_checking_interval': 7
    }
    new_config['MOTD'] = {
        'global_server_motd': ''
    }
    with open ("config.ini", 'w') as config_file:
        new_config.write (config_file)


def async_output_server_info():
    while True:
        time.sleep(10)  
        #os.system('cls' if os.name == 'nt' else 'clear')  # Clear console
        output_server_info()

def output_server_info():
    global servers

    for server in servers:
        server_info = server.server_info
        print(f"{server.name}")
        print(f"\tStatus: {server_info.server_status}")
        print(f"\tConnected Users: {server_info.current_users}")
        print(f"\tNumber of Users: {len(server_info.joined_users) - len(server_info.disconnected_users)}")
        print(f"\tTotal User Joins: {server_info.total_user_joins}")
        print(f"\tTotal User Disconnects: {server_info.total_user_disconnects}")
        print(f"\tCurrent Gamemode: {server_info.previous_gamemode}")
        print(f"\tGamemode Changes: {server_info.gamemode_changes}")
        print(f"\tServer Restarts: {server_info.server_restarts}")
        print()


def init_sockets ():
    server_socket = socket.socket (socket.AF_INET, socket.SOCK_STREAM)
    server_socket.bind (('127.0.0.1', int (read_global_config()['WebServer']['web_server_port']) + 1))
    server_socket.listen(2)

    threading.Thread(target=listen_for_clients, args=(server_socket,)).start()

def listen_for_clients(server_socket): 
    while True:
        client_socket, client_address = server_socket.accept()
        threading.Thread (target=handle_client, args=(client_socket, client_address)).start()
        time.sleep (3)
        
def handle_client (client_socket, client_address):
    try:
        buffer_size = 1024
        data = b""
        client_socket.settimeout (2)
        while True:
            try:
                chunk = client_socket.recv(buffer_size)
                if not chunk:
                    break
                data += chunk
            except socket.timeout:
                break
        
        request_data = json.loads (data)

        data_server = request_data['server']
        data_action = request_data['action']

        if data_action == "start":
            execute_server_start (data_server)
        elif data_action == "restart":
            execute_server_restart (data_server)
        elif data_action == "stop":
            execute_server_stop (data_server)
        elif data_action == "kill":
            execute_server_kill (data_server)
        elif data_action == "get_server_config":
            server = get_server_from_name (data_server)
            config = server.config_path
            response = json.dumps (config)
            client_socket.sendall (response.encode('utf-8'))
        elif data_action == "create":
            formdata = request_data['formdata']
            create_server(formdata)
        elif data_action == "read_report":
            report_hash = request_data['hash']
            UserReport.handle_report (report_hash)
        elif data_action == "delete_report":
            report_hash = request_data['hash']
            UserReport.delete_report (report_hash)
        elif data_action == "ban":
            user_id = request_data['user_id']
    except Exception as e:
        print (f"Error handling client {client_address}: {e}, {traceback.format_exc()}")
    finally:
        client_socket.close()

def main():
    global data_dir, config_dir

    app_name = "Meshed Server Tool"
    app_author = "Skomesh"

    data_dir = user_data_dir (app_name, app_author, ensure_exists=True)
    config_dir = user_config_dir (app_name, app_author, ensure_exists=True)

    configs = get_all_server_paths()
    
    create_log_file()

    for config in configs:
        folder_split = config['folder'].split ('_')
        name = folder_split[1]
        begin_server (name)
    
    global_config = read_global_config()
    
    UserReport.start_report_checking_thread()

    global web_server_online
    global is_using_web_server

    is_using_web_server = ast.literal_eval(global_config['WebServer']['web_server_enabled'])
    if is_using_web_server:
        if ping_web_server():
            web_server_online = True
            init_sockets()
        else:
            start_wait_for_web_server_thread()

    while True:
        time.sleep(3)

if __name__ == "__main__":
    main()
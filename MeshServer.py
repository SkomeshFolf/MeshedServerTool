"""
    # Mesh Server Tool

    Author: Skomesh
    Version 0.3.2

    Mesh Server Tool is a Python script designed to monitor and analyze log files generated by SCP 5k game servers. 
    It keeps track of user joins and leavings and automatically restart the server.

    ## Features

    - Real-time Analysis: Continuously monitors log files for changes and provides real-time analysis.
    - Player Tracking: Tracks player joins and disconnects, by their Steam IDs.
    - Game Mode Changes: Monitors changes in the game mode and logs when transitions occur.

    ## Dependencies

    - pygtail: A Python library for tailing log files.
    - psutil: A cross-platform library for retrieving information on running processes and system utilization.

    Use this command to install the dependencies:
    pip install -r requirements.txt

    ## Configuration

    Edit the configuration file (`config.ini`) to set parameters such as log file path, maximum reloads, etc.
    General Configuration Options:
        - log_file_path:        The directory of the server's log file. The log file should be Pandemic.log.
        - max_reloads:          How many map changes should lead to a full server restart.
        - restricted_gamemode:  Should the server be restricted to only a single gamemode? Leave blank to allow map switching.
        - server_executable:    The directory to the actual server executable. Should be PandemicServer.exe on windows, or PandemicServer on linux.
                                    The executable should be in /Pandemic/Binaries/Linux OR WindowsServer/PandemicServer.exe
        - server_args:          Any arguments to be passed to the server, such as -port and -queryport. Each argument separated by commas
                                    ex. M_WaveSurvival,-port=7777,-queryport=27015
        - monitor_only:         Should the script manage the server by starting and stopping the server, or just monitor logs?
        - active_hours:         What time should the server be active for? In format HH:MM-HH:MM (ex 08:00-18:00)

    ## Usage

    Run the script using Python

    ## TODO 
    - Throttle file checks [X]
    - Perfect the "current player" count 
    - Allow hosting of multiple servers from one script [X]
    - Allow "Monitoring Only" mode 
    - Idle server checking
"""

import re
import subprocess
import time
import pygtail
import threading
import os
import configparser
import psutil
import shutil
import ast
from datetime import datetime, time
import time

class Server:
    def __init__(self, name, config, server_info):
        self.name = name
        self.server_info = server_info

        self.log_file_path = config['log_file_path']
        self.max_reloads = int(config['max_reloads'])
        self.server_executable = config['server_executable']
        self.restricted_gamemode = config['restricted_gamemode']
        self.server_args = config['server_args']
        self.monitor_only = ast.literal_eval(config['monitor_only'])
        if (config['active_hours'] == ''):
            self.active_hours = False
        else:
            timeSplit = config['active_hours'].split("-")
            self.active_hours = True
            self.start_time = datetime.strptime (timeSplit[0], '%H:%M').time()
            self.end_time = datetime.strptime (timeSplit[1], '%H:%M').time()

        self.server_process = None
        self.log = None
        self.config = config

        self.current_line = 0

        self.lock = threading.Lock()

    def init_server (self):
        self.start_server()

        thread = threading.Thread (target=self.analyze_log, daemon=True)
        thread.start()

    def start_server (self):
        self.server_info.server_status_change (2)
        register_server_start (self.name)
        self.reset_vars()

        if not self.server_process:
            server_args_raw = self.server_args
            server_args = server_args_raw.split(',')
            command = [self.server_executable] + server_args
            self.server_process = subprocess.Popen(command)
            self.server_info.server_restarts = self.server_info.server_restarts + 1
            self.server_info.server_status_change (4)

    def stop_server(self):
        self.server_info.server_status_change (0)
        register_server_stop (self.name)
        if self.server_process:
            try:
                parent_pid = self.server_process.pid
                parent = psutil.Process(parent_pid)
                children = parent.children(recursive=True)
                for child in children:
                    child.terminate()
                psutil.wait_procs(children, timeout=10)
                parent.terminate()
                parent.wait(timeout=10)
                self.server_info.server_status_change (-3)
            except psutil.NoSuchProcess:
                pass
            finally:
                self.server_process = None
    def suspend_server(self):
        register_server_suspend (self.name)
        self.stop_server()
        self.server_info.server_status_change (-1)

        while True:
            current_time = datetime.now().time()
            if self.start_time <= current_time <= self.end_time:
                break

            time.sleep (60)
        
        self.server_info.server_status_change (1)
        register_server_wake (self.name)
        self.start_server()
        self.analyze_log()

    def restart_server(self, reason):
        self.server_info.server_status_change (3)
        register_server_restart (self.name, reason)
        self.stop_server()
        self.start_server()

    def reset_vars(self):
        self.log = None
        self.current_line = 0
        self.server_info.reset_variables()

    def analyze_log(self):
        if self.active_hours:
            if not is_active_hours (self.start_time, self.end_time):
                self.suspend_server()
                return
            
        with self.lock:
            server_logging = True
            while server_logging:
                time.sleep(3)

                try:
                    self.log = pygtail.Pygtail(self.log_file_path)
                except FileNotFoundError:
                    print(f"Error: Log file {self.log_file_path} not found.")
                    return
                
                server_active = True

                while server_active:

                    if not self.monitor_only:
                        if self.server_process.poll() != None:
                            self.server_info.server_status_change (-2)
                            self.restart_server("Server crash")
                            server_active = False
                            break
                        
                    with open(self.log_file_path, 'r') as log_file:
                        for _ in range(self.current_line):
                            log_file.readline()

                        for line in log_file:
                            self.current_line += 1

                            game_class = log_is_new_gamemode(line)
                            if game_class:
                                self.server_info.gamemode_change (game_class)

                                if self.active_hours:
                                    if not is_active_hours (self.start_time, self.end_time):
                                        self.suspend_server()
                                        server_active = False
                                        server_logging = False
                                        break

                                if not self.monitor_only:
                                    if self.server_info.gamemode_changes > self.max_reloads:
                                        self.restart_server(f"Server reloaded {self.server_info.gamemode_changes} times")
                                        server_active = False
                                        break
                                    elif self.restricted_gamemode != '' and self.server_info.previous_gamemode != self.restricted_gamemode:
                                        self.restart_server(f"Server loaded a gamemode that is not {self.restricted_gamemode}")
                                        server_active = False
                                        break

                            player_id = log_is_player_joined(line)
                            if player_id:
                                self.server_info.player_join(player_id)

                            player_id = log_is_player_leave(line)
                            if player_id:
                                self.server_info.player_leave(player_id)

                    time.sleep(7)

class ServerInfo:
    def __init__ (self, name, status):
        self.server_name = name
        self.previous_gamemode = None
        self.joined_users = set()
        self.disconnected_users = set()
        self.current_users = set()
        self.gamemode_changes = 0
        self.total_user_joins = 0
        self.total_user_disconnects = 0
        self.server_restarts = 0
        self.server_status = status
    
    def player_join (self, player):
        if player not in self.joined_users:
            self.total_user_joins += 1
            print(f"Player joined {self.server_name}. SteamID: {player}")
            self.joined_users.add(player)
            self.current_users.add(player)
    
    def player_leave (self, player):
        if player not in self.disconnected_users:
            self.total_user_disconnects += 1
            print(f"Player left. SteamID: {player}")
            self.disconnected_users.add(player)
            self.current_users.remove(player)

    def gamemode_change (self, gamemode):
        if gamemode != self.previous_gamemode:
            print (f"{self.server_name}: Gamemode changed to: {gamemode}")
            self.gamemode_changes += 1
            self.previous_gamemode = gamemode
    
    def reset_variables (self):
        self.previous_gamemode = None
        self.joined_users = set()
        self.disconnected_users = set()
        self.current_users = set()
        self.gamemode_changes = 0
        self.total_user_joins = 0
        self.total_user_disconnects = 0

    def server_status_change (self, new_status):
        status_dict = {
            -3: 'Offline',
            -2: 'Crashed',
            -1: 'Suspended',
            0: 'Stopping',
            1: 'Waking',
            2: 'Starting',
            3: 'Restarting',
            4: 'Active'
        }
        self.server_status = status_dict.get (new_status, 'Offline')


servers = []
main_log_file = None

def register_player_join (server, player):
    print (f"Player {player} has joined {server}")
    write_to_log (server, f"Player {player} connected.")

def register_player_leave (server, player):
    print (f"Player {player} has left {server}")
    write_to_log (server, f"Player {player} has disconnected.")

def register_server_restart (server, reason):
    print (f"Server {server} has restarted for: {reason}.")
    write_to_log (server, f"Server restarted for: {reason}.")

def register_server_gamemode (server, gamemode):
    print (f"Server {server} has changed gamemode to {gamemode}")
    write_to_log (server, f"Gamemode changed to {gamemode}.")

def register_server_start (server):
    print (f"Server {server} has started")
    write_to_log (server, f"Server started.")

def register_server_stop (server):
    print (f"Server {server} has stopped")
    write_to_log (server, f"Server stopped.")

def register_server_suspend (server):
    print (f"Server {server} has suspended")
    write_to_log (server, "Server suspended.")

def register_server_wake (server):
    print (f"Server {server} woke from suspending")
    write_to_log (server, "Server waking from suspension.")

def output_server_info():
    for server in servers:
        server_info = server.server_info
        print(f"{server.name}")
        print(f"\tStatus: {server_info.server_status}")
        print(f"\tConnected Users: {server_info.current_users}")
        print(f"\tNumber of Users: {len(server_info.joined_users) - len(server_info.disconnected_users)}")
        print(f"\tTotal User Joins: {server_info.total_user_joins}")
        print(f"\tTotal User Disconnects: {server_info.total_user_disconnects}")
        print(f"\tCurrent Gamemode: {server_info.previous_gamemode}")
        print(f"\tGamemode Changes: {server_info.gamemode_changes}")
        print(f"\tServer Restarts: {server_info.server_restarts}")
        print()

def begin_server (config, name):
    server_instance_info = ServerInfo (name, -3)
    server_instance = Server(name, config, server_instance_info)
    servers.append (server_instance)
    server_instance.init_server()

def log_is_new_gamemode(line):
    match = re.search(r'LogBlueprintUserMessages: Map vote has concluded, travelling to (.+)', line)
    return match.group(1) if match else None

def log_is_player_joined (line):
    match = re.search(r'Sending auth result to user (\d+)', line)
    if match:
        return match.group(1)
    
    return None

def log_is_player_leave (line):
    close_match = re.search(r'UNetConnection::Close: \[UNetConnection\] RemoteAddr: (\d+):', line)

    if close_match:
        return close_match.group(1)
    
    kick_match = re.search(r'Successfully kicked player (\d+)', line)

    if (kick_match):
        return kick_match.group(1)
    
    cleanup = re.search(r'LogNet: UChannel::CleanUp: ChIndex == \d+. Closing connection. \[UChannel\] ChIndex: \d+, Closing: \d+ \[UNetConnection\] RemoteAddr: (\d+):', line)

    if cleanup:
        return cleanup.group(1)
    
    return None

def log_is_player_id(log_file_path):
    steam_ids = set()

    with open(log_file_path, 'r') as log_file:
        for line in log_file:
            matches = re.findall(r'\b\d{17}\b', line)
            steam_ids.update(matches)

    # Log the collected Steam IDs
    print("All Steam IDs in the log file:")
    for steam_id in steam_ids:
        print(steam_id)

def is_active_hours (start_time, end_time):
    current_time = datetime.now().time()
    if start_time <= current_time <= end_time:
        return True
    else:
        return False

def read_config(config_file_path):
    config = configparser.ConfigParser()
    config.read(config_file_path)    
    return config['General']

def get_server_configs():
    configs = []
    # Find all server folders
    server_folders = [folder for folder in os.listdir() if os.path.isdir(folder) and folder.startswith("Server_")]

    for folder in server_folders:
        config_file_path = os.path.join(folder, 'config.ini')
        if os.path.exists(config_file_path):
            config = read_config(config_file_path)
            configs.append({'folder': folder, 'config': config})
        else:
            generate_config (config_file_path)
            config = read_config(config_file_path)
            configs.append({'folder': folder, 'config': config})

    return configs
    
def write_to_log (server, content):
    current_datetime = datetime.now()
    formatted_datetime = current_datetime.strftime("%Y-%m-%d %H:%M:%S")
    with open(log_file_path, 'a') as log_file:
        log_file.write(f"\n[{formatted_datetime}] {server} - {content}")

def create_log_file():
    current_datetime = datetime.now()
    formatted_datetime = current_datetime.strftime("%Y-%m-%d %H:%M:%S")
    if not os.path.exists("log.txt"):
        with open(log_file_path, 'w') as log_file:
            log_file.write(f"[Start of log file: {formatted_datetime}]\n")
    else:
        save_log_file()
        with open(log_file_path, 'w') as log_file:
            log_file.write(f"[Start of log file: {formatted_datetime}]\n")
    
    
    
def save_log_file():
    if not os.path.exists("Logs"):
        os.makedirs("Logs")
    
    current_datetime = datetime.now()
    formatted_datetime = current_datetime.strftime("%Y-%m-%d %H:%M:%S")
    
    shutil.move("log.txt", f"Logs/log_{formatted_datetime}.txt")
    
    with open(log_file_path, 'w') as log_file:
        log_file.write("")
    

def generate_config(config_file_path):
    newConfig = configparser.ConfigParser()
    newConfig['General'] = {
        'log_file_path': '../Pandemic/Saved/Logs/Pandemic.log',
        'max_reloads': '7',
        'restricted_gamemode': '',
        'server_executable': '',
        'server_args': '',
        'monitor_only': False,
        'active_hours': ''
    }

    with open(config_file_path, 'w') as config_file:
        newConfig.write(config_file)

def async_output_server_info():
    while True:
        time.sleep(10)  
        #os.system('cls' if os.name == 'nt' else 'clear')  # Clear console
        output_server_info()

def main():
    configs = get_server_configs()

    for config in configs:
        name = config['folder']
        config = config['config']
        begin_server (config, name)

    threading.Thread(target=async_output_server_info, daemon=True).start()

    while True:
        time.sleep(3)

if __name__ == "__main__":
    main()

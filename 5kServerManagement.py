"""
    # Mesh Server Tool

    Author: Skomesh

    Mesh Server Tool is a Python script designed to monitor and analyze log files generated by SCP 5k game servers. 
    It keeps track of user joins and leavings and automatically restart the server.

    ## Features

    - Real-time Analysis: Continuously monitors log files for changes and provides real-time analysis.
    - Player Tracking: Tracks player joins and disconnects, by their Steam IDs.
    - Game Mode Changes: Monitors changes in the game mode and logs when transitions occur.

    ## Dependencies

    - [pygtail](https://github.com/bgreenlee/pygtail): A Python library for tailing log files.

    ## Configuration

    Edit the configuration file (`config.ini`) to set parameters such as log file path, maximum reloads, etc.

    ## Usage

    Run the script using Python:

    ```bash
    python server_log_analyzer.py
"""

import re
import subprocess
import time
import pygtail
import threading
import os
import configparser

def analyze_log():
    config = read_config()
    log_file_path = config['LOG_FILE_PATH']
    max_reloads = int(config['MAX_RELOADS'])

    current_line = 0
    joined_users = set()
    disconnected_users = set()
    previous_gamemode = None
    gamemode_changes = 0
    total_user_joins = 0
    total_user_disconnects = 0

    log = pygtail.Pygtail(log_file_path)

    def output_server_info():
        print(f"Connected Users: {joined_users - disconnected_users}")
        print(f"Number of Users: {len(joined_users) - len(disconnected_users)}")
        print(f"Total User Joins: {total_user_joins}")
        print(f"Total User Disconnects: {total_user_disconnects}")
        print(f"Current Gamemode: {previous_gamemode}")
        print(f"Current Line: {current_line}")
        print(f"Gamemode Changes: {gamemode_changes}")
    
    def async_output_server_info():
        while True:
            time.sleep(5)  # Wait for 1 minute
            os.system('cls' if os.name == 'nt' else 'clear')  # Clear console
            output_server_info()

    # Start the async function in a separate thread
    threading.Thread(target=async_output_server_info, daemon=True).start()

    while True:
        with open(log_file_path, 'r') as log_file:
            # Move to the last processed line
            for _ in range(current_line):
                log_file.readline()

            # Read lines one by one
            for line in log_file:
                current_line += 1

                game_class = current_gamemode(line)
                if game_class:
                    if game_class != previous_gamemode:
                        gamemode_changes += 1
                        previous_gamemode = game_class
                    print(f"Game mode changed. New Game Class: {game_class}")

                player_id = player_joined(line)
                if player_id and player_id not in joined_users:
                    total_user_joins += 1
                    print(f"Player joined. SteamID: {player_id}")
                    joined_users.add(player_id)

                player_id = player_leave(line)
                if player_id and player_id not in disconnected_users:
                    total_user_disconnects += 1
                    print(f"Player left. SteamID: {player_id}")
                    disconnected_users.add(player_id)

def current_gamemode(line):
    match = re.search(r'LogLoad: Game class is \'(.+)\'', line)
    return match.group(1) if match else None

def player_joined (line):
    match = re.search(r'Sending auth result to user (\d+)', line)
    if match:
        return match.group(1)
    
    return None

def player_leave (line):
    close_match = re.search(r'UNetConnection::Close: \[UNetConnection\] RemoteAddr: (\d+):', line)

    if close_match:
        return close_match.group(1)
    
    kick_match = re.search(r'Successfully kicked player (\d+)', line)

    if (kick_match):
        return kick_match.group(1)
    
    cleanup = re.search(r'LogNet: UChannel::CleanUp: ChIndex == \d+. Closing connection. \[UChannel\] ChIndex: \d+, Closing: \d+ \[UNetConnection\] RemoteAddr: (\d+):', line)

    if cleanup:
        return cleanup.group(1)
    
    return None

def track_and_log_steam_ids(log_file_path):
    steam_ids = set()

    with open(log_file_path, 'r') as log_file:
        for line in log_file:
            # Use a regular expression to find Steam IDs in the format "765611..."
            matches = re.findall(r'\b\d{17}\b', line)
            steam_ids.update(matches)

    # Log the collected Steam IDs
    print("All Steam IDs in the log file:")
    for steam_id in steam_ids:
        print(steam_id)

def read_config():
    config = configparser.ConfigParser()

    if not os.path.exists('config.ini'):
        generate_config()

    config.read('config.ini')
    return config['General']

def generate_config():
    config = configparser.ConfigParser()
    config['General'] = {
        'LOG_FILE_PATH': './Pandemic/Saved/Logs/Pandemic.log',
        'MAX_RELOADS': '7'
    }

    with open('config.ini', 'w') as config_file:
        config.write(config_file)


def main():
    analyze_log()

if __name__ == "__main__":
    main()